use super::syntax;
use super::lex;

grammar;

pub Ident: syntax::Ident = {
    <name: Name> <collision_id: ("#" <UInt>)?> => {
        syntax::Ident {
            name,
            collision_id: collision_id.unwrap_or(0),
        }
    },
};

extern {
    type Location = usize;
    type Error = lex::Error;

    enum lex::Token {
        Name => lex::Token::Name(<String>),
        UInt => lex::Token::UInt(<u64>),

        "move" => lex::Token::KeyMove,
        "func" => lex::Token::KeyFunc,
        "let" => lex::Token::KeyLet,
        "let_exists" => lex::Token::KeyLetExists,
        "in" => lex::Token::KeyIn,
        "make_exists" => lex::Token::KeyMakeExists,
        "of" => lex::Token::KeyOf,

        "forall" => lex::Token::KeyForall,
        "exists" => lex::Token::KeyExists,
        "Version" => lex::Token::KeyVersion,
        "Place" => lex::Token::KeyPlace,

        "#" => lex::Token::NumSign,
        "," => lex::Token::Comma,
        ";" => lex::Token::Semicolon,
        "=" => lex::Token::Equals,
        ":" => lex::Token::Colon,

        "(" => lex::Token::OpenPar,
        ")" => lex::Token::ClosePar,

        "{" => lex::Token::OpenCurly,
        "}" => lex::Token::CloseCurly,
    }
}

// Nonterminals which are just thin wrappers over terminals, for testing the lexer itself:

pub RawName: String = {
    <Name>,
};

pub Whitespace: () = {
    () => (),
};
