use std::rc::Rc;

use super::syntax;
use super::lex;
use types;

grammar;

pub Ident: syntax::Ident = {
    <name: Name> <collision_id: ("#" <UInt>)?> => {
        syntax::Ident {
            name,
            collision_id: collision_id.unwrap_or(0),
        }
    },
};

pub Kind: types::Kind = {
    "*" => types::Kind::Type,
    "Place" => types::Kind::Place,
    "Version" => types::Kind::Version,
    "(" <Kind> ")",
    "(" <params: (<Kind> ";")*> <final_param: Kind?> ")" "->" <result: Kind> => {
        let mut all_params = params;
        if let Some(final_param) = final_param {
            all_params.push(final_param);
        }
        types::Kind::Constructor {
            params: Rc::new(all_params),
            result: Rc::new(result),
        }
    },
};

extern {
    type Location = usize;
    type Error = lex::Error;

    enum lex::Token {
        Name => lex::Token::Name(<String>),
        UInt => lex::Token::UInt(<u64>),

        "move" => lex::Token::KeyMove,
        "func" => lex::Token::KeyFunc,
        "let" => lex::Token::KeyLet,
        "let_exists" => lex::Token::KeyLetExists,
        "in" => lex::Token::KeyIn,
        "make_exists" => lex::Token::KeyMakeExists,
        "of" => lex::Token::KeyOf,

        "forall" => lex::Token::KeyForall,
        "exists" => lex::Token::KeyExists,
        "Version" => lex::Token::KeyVersion,
        "Place" => lex::Token::KeyPlace,

        "#" => lex::Token::NumSign,
        "," => lex::Token::Comma,
        ";" => lex::Token::Semicolon,
        "=" => lex::Token::Equals,
        ":" => lex::Token::Colon,
        "*" => lex::Token::Star,
        "->" => lex::Token::Arrow,

        "(" => lex::Token::OpenPar,
        ")" => lex::Token::ClosePar,

        "{" => lex::Token::OpenCurly,
        "}" => lex::Token::CloseCurly,
    }
}

// Nonterminals which are just thin wrappers over terminals, for testing the lexer itself:

pub RawName: String = {
    <Name>,
};

pub Whitespace: () = {
    () => (),
};
